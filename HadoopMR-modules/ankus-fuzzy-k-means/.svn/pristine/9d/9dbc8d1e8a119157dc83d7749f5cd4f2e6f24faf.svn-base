package org.ankus.mapreduce.algorithms.clustering.FuzzyCMeans;

import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Random;

import org.ankus.util.ArgumentsConstants;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Mapper.Context;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Mapper_Random_Weight extends Mapper<Object, Text, Text, Text>{
	
    int mb = 1024*1024;
    private Logger logger = LoggerFactory.getLogger(Mapper_Random_Weight.class);
    int cluster_count =1;
    @Override
    protected void setup(Context context) throws IOException, InterruptedException
    {
    	Configuration conf = context.getConfiguration();
    	cluster_count = conf.getInt(ArgumentsConstants.K_CNT, 1);
    	
    }
    void manualException(String msg) throws Exception {
		try {
			throw new Exception();
		} catch (Exception e) {
			System.out.println(msg);
			throw e; // 다시 예외를 발생시킨다.
		}
	} // method1메서드의 끝
 
	@Override
	protected void map(Object key, Text value, Context context) throws IOException, InterruptedException
	{
		try
		{
//			String instaneVector = value.toString();		
//			Random random = new Random();			
//			double[] random_weight = new double[cluster_count];
//			String clusters_weight = "";
//			for(int rwi = 0; rwi < random_weight.length; rwi++)
//			{
//				random_weight[rwi] = 1/(double)cluster_count;
//				clusters_weight += random_weight[rwi] + ":"; 
//			}
//			clusters_weight = clusters_weight.substring(0, clusters_weight.length()-1);
//			context.write(new Text(instaneVector), new Text(clusters_weight));
			
			String instaneVector = value.toString();
			double[] random_weight = new double[cluster_count];
			
			String clusters_weight = "";
			Random random = new Random();
			
			//1st Random Vlaue Assign
			double SumOfRandom = 0.0;
			for(int ri = 0; ri < cluster_count; ri++)
			{
				double RandomValue =  (double)(random.nextInt(9)+1)/10.0;
				random_weight[ri] = RandomValue;
				SumOfRandom += RandomValue;
			}
			double RandomValibale_Sum = 0.0;
			for(int ri = 0; ri < cluster_count; ri++)
			{
				random_weight[ri]  = random_weight[ri]  / SumOfRandom;
				clusters_weight += random_weight[ri] + ":"; 
				RandomValibale_Sum += random_weight[ri]; 
			}
			if( Math.abs(1- RandomValibale_Sum) > 0.0000000001)
			{
				throw new Exception("초기 확률 오류.");
			}
			context.write(new Text(instaneVector), new Text(clusters_weight));
		}
		catch(Exception e)
		{
			logger.error(e.toString());
		}
	}

}
