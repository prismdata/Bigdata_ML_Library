/*
 * Copyright (C) 2011 ankus (http://www.openankus.org).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.ankus.mapreduce.algorithms.clustering.em;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Iterator;

import org.ankus.util.Constants;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataInputStream;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;

public class EMClusterInfoMgr {

    public static String mNumericDelimiter = "@@NU@@";
    public static String mNominalDelimiter = "@@NO@@";
	
//	private double baseVarianceParameter = 10;
    private double baseProb = 0.000001;
	
	private class PDF_Features {
		public double sum;
		public double squareSum;
		
		public double average;
		public double variance;

		public PDF_Features()
		{
			sum = 0;
			squareSum = 0;
			average = 0;
			variance = 0;
		}
		
		public boolean equals(PDF_Features value)
		{
			if((this.average==value.average) && (this.variance==value.variance)) return true;
			else return false;
		}
	}
	
	public int m_clusterId = -1;
	
	private HashMap<Integer, PDF_Features> m_numericValueList;
	private HashMap<Integer, HashMap<String, Double>> m_nominalValueList;
	
	public EMClusterInfoMgr()
	{
		m_numericValueList = new HashMap<Integer, PDF_Features>();
		m_nominalValueList = new HashMap<Integer, HashMap<String, Double>>();
	}
	
	public void setClusterID(int id)
	{
		m_clusterId = id;
	}
	
	// for all attribute..
	public boolean addAttributeValue(int index, String value, String dataType)
	{
		if(dataType.equals(Constants.DATATYPE_NUMERIC))
		{	
			PDF_Features valueClass = new PDF_Features();
			if(m_numericValueList.containsKey(index)) valueClass = m_numericValueList.get(index);
		
			double val = Double.parseDouble(value);
			valueClass.sum += val;
			valueClass.squareSum += Math.pow(val, 2);
			
			m_numericValueList.put(index, valueClass);
		}
		else if(dataType.equals(Constants.DATATYPE_NOMINAL))
		{
			if(m_nominalValueList.containsKey(index))
			{
				HashMap<String, Double> attrList = m_nominalValueList.get(index);
				if(attrList.containsKey(value)) attrList.put(value, attrList.get(value) + 1.0);
				else
				{
					attrList.put(value, 1.0);
					m_nominalValueList.put(index, attrList);
				}
			}
			else 
			{
				HashMap<String, Double> newAttr = new HashMap<String, Double>();
				newAttr.put(value, 1.0);
				m_nominalValueList.put(index, newAttr);						
			}
		}
		else return false;
		
		return true;
	}
	
	// for cluster center update reduce job
	public void finalCompute(int dataCnt)
	{
		Iterator<Integer> numericKeySetIter = m_numericValueList.keySet().iterator();
		while(numericKeySetIter.hasNext())
		{
			int key = numericKeySetIter.next();
			
			PDF_Features value = m_numericValueList.get(key);
			value.average = value.sum / (double)dataCnt;
			value.variance = (value.squareSum/(double)dataCnt) - Math.pow(value.average,2);
			
//			if(value.variance == 0) value.variance = value.average / baseVarianceParameter;
//			if(value.variance == 0) value.variance = 1;
			
			m_numericValueList.put(key, value);

		}
		
		Iterator<Integer> nominalKeySetIter = m_nominalValueList.keySet().iterator();
		while(nominalKeySetIter.hasNext())
		{
			int key = nominalKeySetIter.next();			
			HashMap<String, Double> valueMap = m_nominalValueList.get(key);
			
			Iterator<String> valueKeyIter = valueMap.keySet().iterator();
			while(valueKeyIter.hasNext())
			{
				String valueKey = valueKeyIter.next();
				valueMap.put(valueKey, valueMap.get(valueKey) / (double)dataCnt);
			}
			
			m_nominalValueList.put(key, valueMap);
		}
	}
	

	public double getAttributeProbability(int attrIndex, String attrValue, String attrType)
	{
		if(attrType.equals(Constants.DATATYPE_NUMERIC))
		{
            //

			if(m_numericValueList.containsKey(attrIndex))
			{
				PDF_Features pdfValue = m_numericValueList.get(attrIndex);
				if(pdfValue.variance==0)
				{
					if(Double.parseDouble(attrValue) == pdfValue.average) return 1;
					else return baseProb;
				}
				else
				{	
					double powVal = (-1 * Math.pow((Double.parseDouble(attrValue)-pdfValue.average), 2)) / (2 * pdfValue.variance);
					double baseVal = 1 / Math.sqrt(2 * Math.PI * pdfValue.variance);

					return baseVal * Math.pow(Math.E, powVal);
				}
			}
			else return 0;
		}
		else if(attrType.equals(Constants.DATATYPE_NOMINAL))
		{
			if(m_nominalValueList.containsKey(attrIndex))
			{
				HashMap<String, Double> valueMap = m_nominalValueList.get(attrIndex);
				if(valueMap.containsKey(attrValue))
				{
					return valueMap.get(attrValue);
				}
				else return baseProb;
			}
			else return 0;
		}
		
		return 0;
	}
	
	
	// get write string
	public String getClusterInfoString(String delimiter)
	{
		// id setting
		String retStr = m_clusterId + "";
		
		// numeric value setting
		Iterator<Integer> numericKeySetIter = m_numericValueList.keySet().iterator();
		while(numericKeySetIter.hasNext())
		{
			int key = numericKeySetIter.next();
			PDF_Features value = m_numericValueList.get(key);
			retStr += delimiter + key + delimiter + value.average + mNumericDelimiter + value.variance;
		}		
		
		// nominal value setting 
		Iterator<Integer> nominalKeySetIter = m_nominalValueList.keySet().iterator();
		while(nominalKeySetIter.hasNext())
		{
			int key = nominalKeySetIter.next();			
			HashMap<String, Double> valueMap = m_nominalValueList.get(key);
			
			Iterator<String> valueKeyIter = valueMap.keySet().iterator();
			String valueValueStr = "";
			while(valueKeyIter.hasNext())
			{
				String valueKey = valueKeyIter.next();
				valueValueStr += mNominalDelimiter + valueKey + mNominalDelimiter + valueMap.get(valueKey);
			}
			
			retStr += delimiter + key + delimiter + valueValueStr.substring(mNominalDelimiter.length());
		}
		
		return retStr;
	}
	
	// load from written string
	public void loadClusterInfoString(String inputStr, String delimiter)
	{
		m_numericValueList = new HashMap<Integer, PDF_Features>();
		m_nominalValueList = new HashMap<Integer, HashMap<String,Double>>();
		
		String tokens[] = inputStr.split(delimiter);
		
		m_clusterId = Integer.parseInt(tokens[0]);
		
		for(int i=1; i<tokens.length; i++)
		{
			int attrIndex = Integer.parseInt(tokens[i++]);
			String attrValue = tokens[i];

            String subTokens[];
			if(attrValue.contains(mNumericDelimiter))
            {
                subTokens = attrValue.split(mNumericDelimiter);

                PDF_Features value = new PDF_Features();
                value.average = Double.parseDouble(subTokens[0]);
                value.variance = Double.parseDouble(subTokens[1]);

                m_numericValueList.put(attrIndex, value);
            }
            else
            {
                subTokens = attrValue.split(mNominalDelimiter);
                HashMap<String, Double> valueMap = new HashMap<String, Double>();
                for(int k=0; k<subTokens.length; k++)
                {
                    String subKey = subTokens[k++];
                    double subValue = Double.parseDouble(subTokens[k]);
                    valueMap.put(subKey, subValue);
                }
                m_nominalValueList.put(attrIndex, valueMap);
            }

            /*
            String subTokens[] = attrValue.split(subDelimiter);

            if(CommonMethods.isNumeric(subTokens[0]))
			{
				PDF_Features value = new PDF_Features();
				value.average = Double.parseDouble(subTokens[0]);
				value.variance = Double.parseDouble(subTokens[1]);

                m_numericValueList.put(attrIndex, value);
			}
			else
			{
				HashMap<String, Double> valueMap = new HashMap<String, Double>();
				for(int k=0; k<subTokens.length; k++)
				{
					String subKey = subTokens[k++];
					double subValue = Double.parseDouble(subTokens[k]);
					valueMap.put(subKey, subValue);
				}
				m_nominalValueList.put(attrIndex, valueMap);
			}
			*/
		}
	}
	
	public static EMClusterInfoMgr[] loadClusterInfoFile(Configuration conf, Path clusterPath, int clusterCnt, String delimiter) throws IOException
	{
		EMClusterInfoMgr[] clusters = new EMClusterInfoMgr[clusterCnt];
		
		FileStatus[] status = FileSystem.get(conf).listStatus(clusterPath);		
		for(int i=0; i<status.length; i++)
		{
            if(!status[i].getPath().toString().contains("part-r-")) continue;

			FSDataInputStream fin = FileSystem.get(conf).open(status[i].getPath());
			BufferedReader br = new BufferedReader(new InputStreamReader(fin, Constants.UTF8));
			String readStr;
			while((readStr = br.readLine())!=null)
			{	
				int clusterId = Integer.parseInt(readStr.substring(0, readStr.indexOf(delimiter)));
				clusters[clusterId] = new EMClusterInfoMgr();
				clusters[clusterId].loadClusterInfoString(readStr, delimiter);
			}
			br.close();
			fin.close();
		}
		
		return clusters;
	}
	
	
	
	public boolean isEqualClusterInfo(EMClusterInfoMgr cluster, double convergeRate)
	{
		Iterator<Integer> numericAttrIndexIter = m_numericValueList.keySet().iterator();		
		while(numericAttrIndexIter.hasNext())
		{
			int attrIndex = numericAttrIndexIter.next();
			
			if(!cluster.m_numericValueList.containsKey(attrIndex)) return false;			
			else
            {
                // converge modify
                PDF_Features oldPDF = new PDF_Features();
                oldPDF = m_numericValueList.get(attrIndex);

                PDF_Features newPDF = new PDF_Features();
                newPDF = cluster.m_numericValueList.get(attrIndex);

                double gapAvg = Math.abs(oldPDF.average - newPDF.average);
                double gapVar = Math.abs(oldPDF.variance - newPDF.variance);

                if((gapAvg > (oldPDF.average * convergeRate))
                    || (gapVar > (oldPDF.variance * convergeRate))) return false;

                //if(!m_numericValueList.get(attrIndex).equals(cluster.m_numericValueList.get(attrIndex))) return false;
            }
		}
		
		
		Iterator<Integer> nominalAttrIndexIter = m_nominalValueList.keySet().iterator();		
		while(nominalAttrIndexIter.hasNext())
		{	
			int attrIndex = nominalAttrIndexIter.next();


            // converge modify
            HashMap<String, Double> orgValueMap = m_nominalValueList.get(attrIndex);
            HashMap<String, Double> newValueMap = cluster.m_nominalValueList.get(attrIndex);

            Iterator<String> orgValueNameIter = orgValueMap.keySet().iterator();
            while(orgValueNameIter.hasNext())
            {
                String name = orgValueNameIter.next();

                if(!newValueMap.containsKey(name))
                {
                    double orgVal = orgValueMap.get(name);
                    if(orgVal > convergeRate) return false;
                }
                else
                {
                    double orgVal = orgValueMap.get(name);
                    double newVal = newValueMap.get(name);
                    double gap = Math.abs(orgVal - newVal);

                    if(gap > (orgVal * convergeRate)) return false;
                }
            }

            Iterator<String> newValueNameIter = newValueMap.keySet().iterator();
            while(newValueNameIter.hasNext())
            {
                String name = newValueNameIter.next();
                if(!orgValueMap.containsKey(name))
                {
                    double newVal = newValueMap.get(name);
                    if(newVal > convergeRate) return false;
                }
            }

			/*
            if(!cluster.m_nominalValueList.containsKey(attrIndex)) return false;
			else
			{
				HashMap<String, Double> valueMap = m_nominalValueList.get(attrIndex);
				HashMap<String, Double> clusterValueMap = cluster.m_nominalValueList.get(attrIndex);
				
				Iterator<String> valueNameIter = valueMap.keySet().iterator();
				while(valueNameIter.hasNext())
				{
					String name = valueNameIter.next();
					
					if(!clusterValueMap.containsKey(name)) return false;
					else if(!valueMap.get(name).equals(clusterValueMap.get(name))) return false;
				}
			}
			*/
		}
		
		return true;
	}
	
	
	
	
	

}
